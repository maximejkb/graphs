<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<form id = "algorithmForm">
  <input type = "radio" name = "algorithm" value = "DFS" id = "dfs" /> DFS
  <input type = "radio" name = "algorithm" value = "BFS" id = "bfs" /> BFS
  <input type = "radio" name = "algorithm" value = "BFSpaths" id = "bfspaths" /> BFS shortest paths
  <input type = "radio" name = "algorithm" value = "Djikstra's" /> Djikstra's
  <input type = "checkbox" name = "labels" value = "labels" onclick = "toggleLabels()" /> Hide vertex labels
  <input type = "checkbox" name = "weights" value = "weights" onclick = "toggleWeights()" /> Hide edge weights
</form>
<svg width = "1000" height = "1000"> </svg>
<style>
  .algorithmForm {
    float: right;
    position: fixed;
  }
  input {
    display: inline;
  }
</style>

<script>
  //Dummy data just for development use. Array of JSON-style objects.
  var data = [
    {label: "0"},
    {label: "1"},
    {label: "2"},
    {label: "3"},
    {label: "4"},
    {label: "5"},
    {label: "6"},
    {label: "7"},
    {label: "8"},
    {label: "9"},
    {label: "10"},
    {label: "11"},
    {label: "12"},
    {label: "13"},
    {label: "14"},
    {label: "15"},
    {label: "16"},
    {label: "17"},
    {label: "18"},
    {label: "19"},
    {label: "20"},
    {label: "21"},
    {label: "22"},
    {label: "23"},
    {label: "24"},
    {label: "25"},
    {label: "26"},
    {label: "27"},
    {label: "28"},
    {label: "29"},
    {label: "30"},
    {label: "31"},
    {label: "32"},
    {label: "33"},
    {label: "34"},
    {label: "35"},
    {label: "36"},
    {label: "37"},
    {label: "38"},
    {label: "39"},
    {label: "40"},
    {label: "41"},
    {label: "42"},
    {label: "43"},
    {label: "44"},
    {label: "45"},
    {label: "46"},
    {label: "47"},
    {label: "48"},
    {label: "49"},
    {label: "50"},
    {label: "51"},
    {label: "52"},
    {label: "53"},
    {label: "54"},
    {label: "55"},
    {label: "56"},
    {label: "57"},
    {label: "58"},
    {label: "59"},
    {label: "60"},
    {label: "61"},
    {label: "62"},
    {label: "63"},
    {label: "64"},
    {label: "65"},
    {label: "66"},
    {label: "67"},
    {label: "68"},
    {label: "69"},
    {label: "70"},
    {label: "71"},
    {label: "72"},
    {label: "73"},
    {label: "74"},
    {label: "75"},
    {label: "76"},
    {label: "77"},
    {label: "78"},
    {label: "79"},
    {label: "80"},
  ];
  var edges = [
    {source: "1", target: "2", distance: 30},
    {source: "1", target: "3", distance: 30},
    {source: "1", target: "4", distance: 20},
    {source: "1", target: "5", distance: 20},
    {source: "1", target: "6", distance: 10},
    {source: "2", target: "31", distance: 50},
    {source: "2", target: "16", distance: 50},
    {source: "3", target: "2", distance: 30},
    {source: "3", target: "9", distance: 60},
    {source: "4", target: "25", distance: 30},
    {source: "5", target: "27", distance: 30},
    {source: "6", target: "30", distance: 60},
    {source: "15", target: "2", distance: 60},
    {source: "16", target: "1", distance: 50},
    {source: "16", target: "32", distance: 50},
    {source: "16", target: "39", distance: 40},
    {source: "16", target: "38", distance: 40},
    {source: "18", target: "2", distance: 20},
    {source: "21", target: "39", distance: 20},
    {source: "31", target: "38", distance: 30},
    {source: "31", target: "1", distance: 30},
    {source: "31", target: "10", distance: 30},
    {source: "31", target: "3", distance: 40},
    {source: "31", target: "4", distance: 30},
    {source: "31", target: "5", distance: 30},
    {source: "31", target: "6", distance: 30},
    {source: "31", target: "7", distance: 30},
    {source: "31", target: "8", distance: 30},
    {source: "31", target: "9", distance: 30},
    {source: "31", target: "11", distance: 30},
    {source: "14", target: "12", distance: 30},
    {source: "14", target: "13", distance: 30},
    {source: "14", target: "14", distance: 30},
    {source: "14", target: "15", distance: 30},
    {source: "14", target: "16", distance: 50},
    {source: "8", target: "17", distance: 40},
    {source: "8", target: "18", distance: 40},
    {source: "8", target: "19", distance: 50},
    {source: "8", target: "20", distance: 40},
    {source: "8", target: "21", distance: 30},
    {source: "8", target: "22", distance: 40},
    {source: "36", target: "23", distance: 50},
    {source: "36", target: "24", distance: 30},
    {source: "36", target: "25", distance: 30},
    {source: "36", target: "26", distance: 30},
    {source: "36", target: "27", distance: 30},
    {source: "36", target: "28", distance: 30},
    {source: "23", target: "29", distance: 20},
    {source: "23", target: "30", distance: 20},
    {source: "23", target: "32", distance: 20},
    {source: "23", target: "33", distance: 20},
    {source: "23", target: "34", distance: 40},
    {source: "23", target: "35", distance: 40},
    {source: "34", target: "36", distance: 60},
    {source: "34", target: "37", distance: 60},
    {source: "34", target: "38", distance: 40},
    {source: "34", target: "39", distance: 30},
    {source: "40", target: "41", distance: 30},
    {source: "41", target: "42", distance: 30},
    {source: "42", target: "43", distance: 30},
    {source: "43", target: "44", distance: 30},
    {source: "45", target: "46", distance: 30},
    {source: "43", target: "46", distance: 30},
    {source: "46", target: "47", distance: 30},
    {source: "69", target: "50", distance: 10},
    {source: "69", target: "51", distance: 10},
    {source: "69", target: "49", distance: 10},
    {source: "49", target: "50", distance: 15},
    {source: "49", target: "48", distance: 30},
    {source: "50", target: "51", distance: 15},
    {source: "50", target: "55", distance: 30},
    {source: "51", target: "49", distance: 15},
    {source: "51", target: "56", distance: 30},
    {source: "49", target: "52", distance: 30},
    {source: "50", target: "53", distance: 30},
    {source: "51", target: "54", distance: 30},
    {source: "48", target: "52", distance: 30},
    {source: "54", target: "56", distance: 30},
    {source: "55", target: "53", distance: 30},
    {source: "48", target: "56", distance: 30},
    {source: "52", target: "55", distance: 30},
    {source: "53", target: "54", distance: 30},
    {source: "48", target: "57", distance: 30},
    {source: "48", target: "58", distance: 30},
    {source: "57", target: "58", distance: 30},
    {source: "58", target: "59", distance: 30},
    {source: "52", target: "59", distance: 30},
    {source: "52", target: "60", distance: 30},
    {source: "59", target: "60", distance: 30},
    {source: "60", target: "61", distance: 30},
    {source: "55", target: "61", distance: 30},
    {source: "55", target: "62", distance: 30},
    {source: "61", target: "62", distance: 30},
    {source: "62", target: "63", distance: 30},
    {source: "53", target: "63", distance: 30},
    {source: "53", target: "64", distance: 30},
    {source: "63", target: "64", distance: 30},
    {source: "64", target: "65", distance: 30},
    {source: "54", target: "65", distance: 30},
    {source: "54", target: "66", distance: 30},
    {source: "65", target: "66", distance: 30},
    {source: "66", target: "67", distance: 30},
    {source: "56", target: "67", distance: 30},
    {source: "56", target: "68", distance: 30},
    {source: "67", target: "68", distance: 30},
    {source: "57", target: "68", distance: 30}
  ]

  //Get the height and width of the browser window.
  var w = window.innerWidth;
  var h = window.innerHeight;

  //Select the svg element of the HTML page and set its height and width to full.
  var svg = d3.select("svg");
  svg.attr("width", w).attr("height", h);

  //Iniitialize the d3 graph visualization library object, forceSimulation.
  //The force 'charge' represents a global force that causes nodes to repel
  //each other (a positive strength would simulate gravity/attraction). The
  //force 'center' puts the nodes in the center of the SVG canvas.
  var simulation = d3.forceSimulation()
  .force('charge', d3.forceManyBody().strength(-120).distanceMax(400))
  .force('center', d3.forceCenter(w / 2, h / 2));

  //We also add a link force, proportional to the strength of each link.
  simulation.force('link', d3.forceLink()
    .id(edge => edge.label)
    .distance(edge => edge.distance));

  //Finally, we set the alphaTarget (asymptote of exponentially-decaying cooling
  //parameter) to 0.2, so it never reaches alhpaMin.
  simulation.alphaTarget(0.1);

  //Now we define a function to be called on drag-drop events.
  var dragDrop = d3.drag()
    .on('start', node => {
      node.fx = node.x;
      node.fy = node.y;
    })
    .on('drag', node => {
      simulation.alphaTarget(0.7).restart();
      node.fx = d3.event.x;
      node.fy = d3.event.y;
    })
    .on('end', node => {
      if (!d3.event.active) {
        simulation.alphaTarget(0.1).restart();
      }
      node.fx = null;
      node.fy = null;
  });

  //The persistent arrays to track progression of graph traversals -- DFS, BFS,
  //Djikstra's, A*, etc. while maintaining ability to render between ticks
  //(circumventing natural recursion).
  var marked = new Array();
  //A map to track which edge led to a vertex in a shortest path algorithm.
  var edgeTo = new Map();
  var fringe = new Array();
  //When we run shortest paths, we mark all neighboring vertices before visiting them,
  //in order to "claim" them in a way. When we consider only unmarked neighbors of future
  //vertices, we don't want neighbors of the current included because clearly, we're seeing
  //it at current sooner, so the path through current is shorter. But because we can't rely
  //on recursion to enforce a natural order, we have to also keep track of nodes we've actually
  //visited, so that we don't visit in circles.
  var visited = new Array();
  //Toggles simulation to call runAlgorithm() on tick.
  var searchComplete = true;

  //Colors the node depending on whether it is marked or not.
  function colorMarkedNode(node) {
    return marked.includes(node) ? "DarkSeaGreen" : "LightGray";
  }

  //Colors the text depending on whether the node is marked or not.
  function colorMarkedText(node) {
    return marked.includes(node) ? "DarkSeaGreen" : "DarkGray";
  }

  //Colors the edge weight text depending on whether the edge is selected or not.
  function colorMarkedEdge(edge) {
    return (marked.includes(edge.source) || marked.includes(edge.target)) ? "DarkSeaGreen" : "LightGray";
  }

  //Delegator function. Directs traffic.
  function startAlgorithm(current) {
    //Deselect any previous shortest path highlights.
    edgeElements.attr("stroke-width", 1);
    if (document.getElementById("bfspaths").checked) {
      startPaths(current);
    } else {
      startNodeSearch(current);
    }
  }

  //Delegator function. Directs traffic from tick() simulation function.
  function runAlgorithm() {
    if (document.getElementById("bfspaths").checked) {
      runPaths();
    } else {
      runNodeSearch();
    }
  }

  //Sub-routine for DFS and BFS -- returns an array of unmarked vertices. Returns
  //empty array if there are no more unmarked vertices.
  function getUnmarkedNeighbors(current) {
    return edges.reduce((neighbors, edge) => {
      if (!(marked.includes(edge.source)) && edge.target.label === current.label) {
        neighbors.push(edge.source);
      } else if (!(marked.includes(edge.target)) && edge.source.label === current.label) {
        neighbors.push(edge.target);
      }
      return neighbors;
    }, [current]);
  }

  //Initiates DFS/BFS starting at the vertex clicked.
  function startNodeSearch(current) {
    //Start off the marked array.
    marked.push(current);

    //Give initial values to fringe.
    var unmarkedNeighbors = getUnmarkedNeighbors(current);
    unmarkedNeighbors.sort(neighborSort);
    unmarkedNeighbors.forEach((neighbor) => {
      if (neighbor != current) {
        fringe.push(neighbor);
      }
    });

    //Toggle simulation to call runSearch() on each tick.
    searchComplete = false;

    //Color nodes appropriately.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
    weightElements.attr("fill", edge => colorMarkedEdge(edge));
  }

  //Performs the appropriate action depending on algorithm.
  function visitAction(nodes) {
    if (document.getElementById("dfs").checked) {
      //Treats the Javascript array as a L.I.F.O. stack.
      return nodes.pop();
    } else if (document.getElementById("bfs").checked || document.getElementById("bfspaths").checked) {
      //Treats the Javascript array as a F.I.F.O. queue.
      return nodes.shift();
    }
  }

  //Sorts the array appropriately so that the label values influence order
  //of enqueuing to the fringe.
  function neighborSort(node1, node2) {
    if (document.getElementById("bfs").checked || document.getElementById("bfspaths").checked) {
      //We want to insert in decreasing order for a F.I.F.O. stack (BFS).
      return parseInt(node1.label) - parseInt(node2.label);
    } else {
      //We want to insert in increasing order for a L.I.F.O. stack (DFS) or
      //default, since this presents a natural order.
      return parseInt(node2.label) - parseInt(node1.label);
    }
  }

  //Performs a "frame-by-frame" version of search for compatibility with rendering.
  function runNodeSearch() {
    //Take the last item inserted from the stack.
    var current = visitAction(fringe);

    //Since we're not progressing recursively, we might consider already-visited
    //vertices (since we add to the fringe before marking, and can't rely on order
    //of calls to create a natural order).
    while (marked.includes(current)) {
      current = visitAction(fringe);
    }

    //If we empty the fringe looking for unmarked vertices, it means there are no
    //unvisited and unmarked vertices. Therefore, we're done. The frame-by-frame
    //analog of a base case.
    if (current == undefined) {
      searchComplete = true;
      //Reset persistent arrays.
      marked = new Array();
      fringe = new Array();
      return;
    }

    //Regular search begins here: Mark current.
    marked.push(current);

    //Fetch neighbors. Sort before inserting so we access in the correct order
    //without losing the priority of the overall list.
    var unmarkedNeighbors = getUnmarkedNeighbors(current);
    unmarkedNeighbors.sort(neighborSort);

    //Color nodes appropriately. Green edges represent edges to/from items that are
    //marked -- the edges to nodes that are in the fringe.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
    weightElements.attr("fill", edge => colorMarkedEdge(edge));

    //"Frame-by-frame" recursion (saving the state at the end of each round with
    //a persistent array of not-yet-considered neighbors).
    unmarkedNeighbors.forEach((neighbor) => {
      if (neighbor != current) {
        fringe.push(neighbor);
      }
    });
  }

  function startPaths(clickedNode) {
    //Start off the marked array.
    marked.push(clickedNode);
    visited.push(clickedNode);
    edgeTo.set(clickedNode, clickedNode);

    //Give initial values to fringe.
    var unmarkedNeighbors = getUnmarkedNeighbors(clickedNode);
    unmarkedNeighbors.sort(neighborSort);
    unmarkedNeighbors.forEach((neighbor) => {
      if (neighbor != clickedNode) {
        marked.push(neighbor);
        fringe.push(neighbor);
        edgeTo.set(neighbor, clickedNode);
      }
    });

    //Toggle simulation to call runSearch() on each tick.
    searchComplete = false;

    //Color nodes appropriately.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
    weightElements.attr("fill", edge => colorMarkedEdge(edge));
  }

  //Performs a "frame-by-frame" version of shortest paths for compatibility with rendering.
  //Marks all neighboring vertices, as per shortest paths algorithm -- does not mark upon
  //visitation, like in BFS/DFS normal. Therefore, visualization seems to slow (because
  //each individual marking is not visualized).
  function runPaths() {
    //Take the first item inserted from the fringe.
    var current = visitAction(fringe);

    //Since we're not progressing recursively, we might consider already-visited
    //vertices (since we add to the fringe before marking, and can't rely on order
    //of calls to create a natural order).
    while (visited.includes(current)) {
      current = visitAction(fringe);
    }

    //If we empty the fringe looking for unvisited vertices, it means there are no
    //unvisited and unmarked vertices. Therefore, we're done. The frame-by-frame
    //analog of a base case.
    if (current == undefined) {
      searchComplete = true;
      //Reset persistent arrays. Clear colorings.
      marked = new Array();
      visited = new Array();
      fringe = new Array();
      nodeElements.attr("fill", node => colorMarkedNode(node));
      textElements.attr("fill", text => colorMarkedText(text));
      edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
      weightElements.attr("fill", edge => colorMarkedEdge(edge));
      highlightShortestPaths();
      edgeTo = new Map();
      return;
    }

    //This node has already been marked since it is a neighbor of some other previously
    //visited node. But now we have to register that it has been visited.
    visited.push(current);

    //Fetch neighbors. Sort before inserting so we access in the correct order
    //without losing the priority of the overall list.
    var unmarkedNeighbors = getUnmarkedNeighbors(current);
    unmarkedNeighbors.sort(neighborSort);

    //Color nodes appropriately. Green edges represent edges to/from items that are
    //marked -- the edges to nodes that are in the fringe.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
    weightElements.attr("fill", edge => colorMarkedEdge(edge));
    //"Frame-by-frame" recursion (saving the state at the end of each round with
    //a persistent array of not-yet-considered neighbors).
    unmarkedNeighbors.forEach((neighbor) => {
      if (neighbor != current) {
        marked.push(neighbor);
        fringe.push(neighbor);
        edgeTo.set(neighbor, current);
      }
    });
  }

  function highlightShortestPaths() {
    //Color nodes appropriately.
    nodeElements.attr("fill", node => {
      return edgeTo.has(node) ? "DarkSeaGreen" : "LightGray";
    });
    textElements.attr("fill", node => {
      return edgeTo.has(node) ? "DarkSeaGreen" : "LightGray";
    });
    edgeElements.attr("stroke", edge => {
      return (edgeTo.get(edge.source) === edge.target
      || edgeTo.get(edge.target) === edge.source) ? "DarkSeaGreen" : "LightGray";
    }).attr("stroke-width", edge => {
      return (edgeTo.get(edge.source) === edge.target
      || edgeTo.get(edge.target) === edge.source) ? 2 : 1;
    });
    weightElements.attr("fill", edge => {
      return (edgeTo.get(edge.source) === edge.target
      || edgeTo.get(edge.target) === edge.source) ? "DarkSeaGreen" : "LightGray";
    }).attr("stroke-width", edge => {
      return (edgeTo.get(edge.source) === edge.target
      || edgeTo.get(edge.target) === edge.source) ? 2 : 1;
    });
  }

  //Toggles text visibility: if opacity is 0, sets to 1. If opacity is 1, sets
  //to 0.
  function toggleLabels() {
    var currentOpacity = textElements.attr("fill-opacity");
    textElements.attr("fill-opacity", 1 - currentOpacity);
  }

  //Toggles edge weight visibility: if opacity is 0, sets to 1. If opacity is 1,
  //sets to 0.
  function toggleWeights() {
    var currentOpacity = weightElements.attr("fill-opacity");
    weightElements.attr("fill-opacity", 1 - currentOpacity);
  }

  //Create SVG line elements for each of our links/edges.
  var edgeElements = svg.append('g')
    .selectAll("line")
    .data(edges)
    .enter().append("line")
      .attr("stroke-width", 1)
      .attr("stroke", "LightGray");

  //Create SVG circles for each of our data points.
  var nodeElements = svg.append('g')
  .selectAll("circle")
  .data(data)
  .enter().append("circle")
    .attr("r", 10)
    .attr("fill", "LightGray")
    .on("click", startAlgorithm);

  //Link the dragDrop function to a call from a node.
  nodeElements.call(dragDrop);

  //Create SVG text labels for each of our data points.
  var textElements = svg.append('g')
  .selectAll("text")
  .data(data)
  .enter().append("text")
    .text(node => node.label)
    .attr("font-size", 15)
    .attr("fill", "DarkGray")
    .attr("fill-opacity", 1)
    .attr("dx", 15)
    .attr("dy", 5);

  var weightElements = svg.append('g')
    .selectAll("text")
    .data(edges)
    .enter().append("text")
      .text(edge => edge.distance)
      .attr("font-size", 8)
      .attr("fill", "DarkGray")
      .attr("fill-opacity", 1)
      .attr("dx", -2)
      .attr("dy", 0);

  //A timer which slows the progression of the graph traversal (only progresses the
  //traversal every 5 ticks).
  var timer = 0;

  //On each time tick of the simulation, this function recalculates position.
  simulation.nodes(data).on("tick", () => {
    //Increment timer and runDFS if the search is still ongoing.
    if (!searchComplete) {
      //If the simulation's alpha ("cooling parameter") falls below the threshold
      //simulation.alphaMin (generally 0.001), ticking stops. Can't have this
      //happening mid-search, so keep alpha artificially elevated.
      simulation.alphaTarget(0.1).restart();
      if (timer == 0) {
        runAlgorithm();
      }
    }
    timer = (timer + 1) % 10;

    nodeElements
    .attr("cx", node => node.x)
    .attr("cy", node => node.y);
    textElements
    .attr("x", node => node.x)
    .attr("y", node => node.y);
    edgeElements
    .attr("x1", edge => edge.source.x)
    .attr("x2", edge => edge.target.x)
    .attr("y1", edge => edge.source.y)
    .attr("y2", edge => edge.target.y);
    weightElements
    .attr("x", edge => (edge.source.x + edge.target.x) / 2)
    .attr("y", edge => (edge.source.y + edge.target.y) / 2);
  });

  //Link the link force in the simulation to the edges dataset.
  simulation.force('link').links(edges);
</script>
</html>
