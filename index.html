<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v4.min.js"></script>
<form id = "algorithmForm">
  <input type = "radio" name = "algorithm" value = "DFS" id = "dfs" /> DFS
  <input type = "radio" name = "algorithm" value = "BFS" id = "bfs" /> BFS
  <input type = "radio" name = "algorithm" value = "Djikstra's" /> Djikstra's
</form>
<svg width = "1000" height = "1000"> </svg>
<style>
  .algorithmForm {
    float: right;
    position: fixed;
  }
  input {
    display: inline;
  }
</style>

<script>
  //Dummy data just for development use. Array of JSON-style objects.
  var data = [
    {label: "0"},
    {label: "1"},
    {label: "2"},
    {label: "3"},
    {label: "4"},
    {label: "5"},
    {label: "6"},
    {label: "7"},
    {label: "8"},
    {label: "9"},
    {label: "10"},
    {label: "11"},
    {label: "12"},
    {label: "13"},
    {label: "14"},
    {label: "15"},
    {label: "16"},
    {label: "17"},
    {label: "18"},
    {label: "19"},
    {label: "20"},
    {label: "21"},
    {label: "22"},
    {label: "23"},
    {label: "24"},
    {label: "25"},
    {label: "26"},
    {label: "27"},
    {label: "28"},
    {label: "29"},
    {label: "30"},
    {label: "31"},
    {label: "32"},
    {label: "33"},
    {label: "34"},
    {label: "35"},
    {label: "36"},
    {label: "37"},
    {label: "38"},
    {label: "39"},
    {label: "40"},
    {label: "41"},
    {label: "42"},
    {label: "43"},
    {label: "44"},
    {label: "45"},
    {label: "46"},
    {label: "47"}
  ];
  var edges = [
    {source: "1", target: "2", distance: 30},
    {source: "1", target: "3", distance: 30},
    {source: "1", target: "4", distance: 20},
    {source: "1", target: "5", distance: 20},
    {source: "1", target: "6", distance: 10},
    {source: "2", target: "31", distance: 50},
    {source: "2", target: "16", distance: 50},
    {source: "3", target: "2", distance: 30},
    {source: "3", target: "9", distance: 60},
    {source: "4", target: "25", distance: 30},
    {source: "5", target: "27", distance: 30},
    {source: "6", target: "30", distance: 60},
    {source: "15", target: "2", distance: 60},
    {source: "16", target: "1", distance: 50},
    {source: "16", target: "32", distance: 50},
    {source: "16", target: "39", distance: 40},
    {source: "16", target: "38", distance: 40},
    {source: "18", target: "2", distance: 20},
    {source: "21", target: "39", distance: 20},
    {source: "31", target: "38", distance: 30},
    {source: "31", target: "1", distance: 30},
    {source: "31", target: "10", distance: 30},
    {source: "31", target: "3", distance: 40},
    {source: "31", target: "4", distance: 30},
    {source: "31", target: "5", distance: 30},
    {source: "31", target: "6", distance: 30},
    {source: "31", target: "7", distance: 30},
    {source: "31", target: "8", distance: 30},
    {source: "31", target: "9", distance: 30},
    {source: "31", target: "11", distance: 30},
    {source: "14", target: "12", distance: 30},
    {source: "14", target: "13", distance: 30},
    {source: "14", target: "14", distance: 30},
    {source: "14", target: "15", distance: 30},
    {source: "14", target: "16", distance: 50},
    {source: "8", target: "17", distance: 40},
    {source: "8", target: "18", distance: 40},
    {source: "8", target: "19", distance: 50},
    {source: "8", target: "20", distance: 40},
    {source: "8", target: "21", distance: 30},
    {source: "8", target: "22", distance: 40},
    {source: "36", target: "23", distance: 50},
    {source: "36", target: "24", distance: 30},
    {source: "36", target: "25", distance: 30},
    {source: "36", target: "26", distance: 30},
    {source: "36", target: "27", distance: 30},
    {source: "36", target: "28", distance: 30},
    {source: "23", target: "29", distance: 20},
    {source: "23", target: "30", distance: 20},
    {source: "23", target: "32", distance: 20},
    {source: "23", target: "33", distance: 20},
    {source: "23", target: "34", distance: 40},
    {source: "23", target: "35", distance: 40},
    {source: "34", target: "36", distance: 60},
    {source: "34", target: "37", distance: 60},
    {source: "34", target: "38", distance: 40},
    {source: "34", target: "39", distance: 30},
    {source: "40", target: "41", distance: 30},
    {source: "41", target: "42", distance: 30},
    {source: "42", target: "43", distance: 30},
    {source: "43", target: "44", distance: 30},
    {source: "45", target: "46", distance: 30},
    {source: "43", target: "46", distance: 30},
    {source: "46", target: "47", distance: 30}

  ]

  //Get the height and width of the browser window.
  var w = window.innerWidth;
  var h = window.innerHeight;

  //Select the svg element of the HTML page and set its height and width to full.
  var svg = d3.select("svg");
  svg.attr("width", w).attr("height", h);

  //Iniitialize the d3 graph visualization library object, forceSimulation.
  //The force 'charge' represents a global force that causes nodes to repel
  //each other (a positive strength would simulate gravity/attraction). The
  //force 'center' puts the nodes in the center of the SVG canvas.
  var simulation = d3.forceSimulation()
  .force('charge', d3.forceManyBody().strength(-120).distanceMax(400))
  .force('center', d3.forceCenter(w / 2, h / 2));

  //We also add a link force, proportional to the strength of each link.
  simulation.force('link', d3.forceLink()
    .id(edge => edge.label)
    .distance(edge => edge.distance));

  //Finally, we set the alphaTarget (asymptote of exponentially-decaying cooling
  //parameter) to 0.2, so it never reaches alhpaMin.
  simulation.alphaTarget(0.1);

  //Now we define a function to be called on drag-drop events.
  var dragDrop = d3.drag()
    .on('start', node => {
      node.fx = node.x;
      node.fy = node.y;
    })
    .on('drag', node => {
      simulation.alphaTarget(0.7).restart();
      node.fx = d3.event.x;
      node.fy = d3.event.y;
    })
    .on('end', node => {
      if (!d3.event.active) {
        simulation.alphaTarget(0.1).restart();
      }
      node.fx = null;
      node.fy = null;
  });

  //The persistent arrays to track progression of graph traversals -- DFS, BFS,
  //Djikstra's, A*, etc. while maintaining ability to render between ticks
  //(circumventing natural recursion).
  var marked = new Array();
  var fringe = new Array();
  var searchComplete = true;

  //Colors the node depending on whether it is marked or not.
  function colorMarkedNode(node) {
    return marked.includes(node) ? "DarkSeaGreen" : "LightGray";
  }

  //Colors the text depending on whether the node is marked or not.
  function colorMarkedText(node) {
    return marked.includes(node) ? "DarkSeaGreen" : "DarkGray";
  }

  function colorMarkedEdge(edge) {
    return (marked.includes(edge.source) || marked.includes(edge.target)) ? "DarkSeaGreen" : "LightGray";
  }

  //Sub-routine for DFS and BFS -- returns an array of unmarked vertices. Returns
  //empty array if there are no more unmarked vertices.
  function getUnmarkedNeighbors(current) {
    return edges.reduce((neighbors, edge) => {
      if (!(marked.includes(edge.source)) && edge.target.label === current.label) {
        neighbors.push(edge.source);
      } else if (!(marked.includes(edge.target)) && edge.source.label === current.label) {
        neighbors.push(edge.target);
      }
      return neighbors;
    }, [current]);
  }

  //Initiates DFS/BFS starting at the vertex clicked.
  function startNodeSearch(current) {
    //Start off the marked array.
    marked.push(current);

    //Give initial values to fringe.
    var unmarkedNeighbors = getUnmarkedNeighbors(current);
    unmarkedNeighbors.forEach((neighbor) => {
      fringe.push(neighbor);
    });

    //Toggle simulation to call runDFS() on each tick.
    searchComplete = false;

    //Color nodes appropriately.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));
  }

  //Performs the appropriate action depending on algorithm.
  function visitAction(nodes) {
    if (document.getElementById("dfs").checked) {
      //Treats the Javascript array as a L.I.F.O. stack.
      return nodes.pop();
    } else if (document.getElementById("bfs").checked) {
      //Treats the Javascript array as a F.I.F.O. queue.
      return nodes.shift();
    }
  }

  //Performs a "frame-by-frame" version of DFS for compatibility with rendering.
  function runSearch() {
    //Take the last item inserted from the stack.
    var current = visitAction(fringe);

    //Since we're not progressing recursively, we might consider already-visited
    //vertices (since we add to the fringe before marking, and can't rely on order
    //of calls to create a natural order).
    while (marked.includes(current)) {
      current = visitAction(fringe);
    }

    //If we empty the fringe looking for unmarked vertices, it means there are no
    //unvisited and unmarked vertices. Therefore, we're done. The frame-by-frame
    //analog of a base case.
    if (current == undefined) {
      searchComplete = true;
      //Reset persistent arrays.
      marked = new Array();
      fringe = new Array();
      return;
    }

    //Regular DFS begins here: Mark current.
    marked.push(current);

    //Fetch neighbors.
    var unmarkedNeighbors = getUnmarkedNeighbors(current);

    //Color nodes appropriately. Green edges represent edges to/from items that are
    //marked -- the edges to nodes that are in the fringe.
    nodeElements.attr("fill", node => colorMarkedNode(node));
    textElements.attr("fill", text => colorMarkedText(text));
    edgeElements.attr("stroke", edge => colorMarkedEdge(edge));

    //"Frame-by-frame" recursion (saving the state at the end of each round with
    //a persistent array of not-yet-considered neighbors).
    unmarkedNeighbors.forEach((neighbor) => {
      fringe.push(neighbor);
    });
  }

  //Create SVG line elements for each of our links/edges.
  var edgeElements = svg.append('g')
    .selectAll("line")
    .data(edges)
    .enter().append("line")
      .attr("stroke-width", 1)
      .attr("stroke", "LightGray");

  //Create SVG circles for each of our data points.
  var nodeElements = svg.append('g')
  .selectAll("circle")
  .data(data)
  .enter().append("circle")
    .attr("r", 10)
    .attr("fill", "LightGray")
    .on("click", startNodeSearch);

  //Link the dragDrop function to a call from a node.
  nodeElements.call(dragDrop);

  //Create SVG text labels for each of our data points.
  var textElements = svg.append('g')
  .selectAll("text")
  .data(data)
  .enter().append("text")
    .text(node => node.label)
    .attr("font-size", 15)
    .attr("fill", "DarkGray")
    .attr("dx", 15)
    .attr("dy", 5);

  //A timer which slows the progression of the graph traversal (only progresses the
  //traversal every 5 ticks).
  var timer = 0;

  //On each time tick of the simulation, this function recalculates position.
  simulation.nodes(data).on("tick", () => {
    //Increment timer and runDFS if the search is still ongoing.
    if (!searchComplete) {
      //If the simulation's alpha ("cooling parameter") falls below the threshold
      //simulation.alphaMin (generally 0.001), ticking stops. Can't have this
      //happening mid-search, so keep alpha artificially elevated.
      simulation.alphaTarget(0.1).restart();
      if (timer == 0) {
        runSearch();
      }
    }
    timer = (timer + 1) % 10;

    nodeElements
    .attr("cx", node => node.x)
    .attr("cy", node => node.y);
    textElements
    .attr("x", node => node.x)
    .attr("y", node => node.y);
    edgeElements
    .attr("x1", edge => edge.source.x)
    .attr("x2", edge => edge.target.x)
    .attr("y1", edge => edge.source.y)
    .attr("y2", edge => edge.target.y);
  });

  //Link the link force in the simulation to the edges dataset.
  simulation.force('link').links(edges);
</script>
</html>
